import {
  require_react_dom
} from "./chunk-QXLG2TGQ.js";
import {
  __toESM,
  require_react
} from "./chunk-I4MZPW7S.js";

// node_modules/@ibm-watson/assistant-web-chat-react/dist/index.es.js
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var semver = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
var validateAndParse = (version) => {
  if (typeof version !== "string") {
    throw new TypeError("Invalid argument expected string");
  }
  const match = version.match(semver);
  if (!match) {
    throw new Error(`Invalid argument not valid semver ('${version}' received)`);
  }
  match.shift();
  return match;
};
var isWildcard = (s) => s === "*" || s === "x" || s === "X";
var tryParse = (v) => {
  const n = parseInt(v, 10);
  return isNaN(n) ? v : n;
};
var forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];
var compareStrings = (a, b) => {
  if (isWildcard(a) || isWildcard(b))
    return 0;
  const [ap, bp] = forceType(tryParse(a), tryParse(b));
  if (ap > bp)
    return 1;
  if (ap < bp)
    return -1;
  return 0;
};
var compareSegments = (a, b) => {
  for (let i = 0; i < Math.max(a.length, b.length); i++) {
    const r = compareStrings(a[i] || "0", b[i] || "0");
    if (r !== 0)
      return r;
  }
  return 0;
};
var compareVersions = (v1, v2) => {
  const n1 = validateAndParse(v1);
  const n2 = validateAndParse(v2);
  const p1 = n1.pop();
  const p2 = n2.pop();
  const r = compareSegments(n1, n2);
  if (r !== 0)
    return r;
  if (p1 && p2) {
    return compareSegments(p1.split("."), p2.split("."));
  } else if (p1 || p2) {
    return p1 ? -1 : 1;
  }
  return 0;
};
function UserDefinedResponsePortalsContainer(_a) {
  var webChatInstance = _a.webChatInstance, renderResponse = _a.renderResponse, userDefinedResponseEvents = _a.userDefinedResponseEvents;
  return import_react.default.createElement(import_react.default.Fragment, null, userDefinedResponseEvents.map(function mapEvent(event, index) {
    return (
      // eslint-disable-next-line react/no-array-index-key
      import_react.default.createElement(UserDefinedResponseComponentPortal, { key: index, hostElement: event.data.element }, renderResponse(event, webChatInstance))
    );
  }));
}
function UserDefinedResponseComponentPortal(_a) {
  var hostElement = _a.hostElement, children = _a.children;
  return import_react_dom.default.createPortal(children, hostElement);
}
var UserDefinedResponsePortalsContainerExport = import_react.default.memo(UserDefinedResponsePortalsContainer);
var DEFAULT_BASE_URL = "https://web-chat.global.assistant.watson.appdomain.cloud";
var debug = false;
function WebChatContainer(_a) {
  var onBeforeRender = _a.onBeforeRender, onAfterRender = _a.onAfterRender, renderUserDefinedResponse = _a.renderUserDefinedResponse, config = _a.config, instanceRef = _a.instanceRef, hostURL = _a.hostURL;
  var _b = (0, import_react.useState)(), instance = _b[0], setInstance = _b[1];
  var _c = (0, import_react.useState)([]), userDefinedResponseEvents = _c[0], setUserDefinedResponseEvents = _c[1];
  var managedWebChatRef = (0, import_react.useRef)();
  var previousConfigRef = (0, import_react.useRef)();
  (0, import_react.useEffect)(function() {
    var previousConfig = previousConfigRef.current;
    previousConfigRef.current = config;
    if (previousConfig !== config) {
      destroyWebChat(managedWebChatRef.current, setInstance, instanceRef);
      var managedWebChat_1 = {
        instance: null,
        shouldDestroy: false,
        webChatConfig: config
      };
      managedWebChatRef.current = managedWebChat_1;
      logger(managedWebChat_1.webChatConfig, "Creating a new web chat due to configuration change.");
      loadWebChat(managedWebChat_1, hostURL, setInstance, instanceRef, onBeforeRender, onAfterRender, setUserDefinedResponseEvents).catch(function(error) {
        logger(managedWebChat_1.webChatConfig, "An error occurred loading web chat", error);
        destroyWebChat(managedWebChat_1, setInstance, instanceRef);
      });
      return function() {
        logger(managedWebChat_1.webChatConfig, "Destroying web chat due to component unmounting.");
        destroyWebChat(managedWebChat_1, setInstance, instanceRef);
        previousConfigRef.current = null;
      };
    }
    return void 0;
  }, [config, hostURL]);
  if (renderUserDefinedResponse && instance) {
    return import_react.default.createElement(UserDefinedResponsePortalsContainerExport, { webChatInstance: instance, renderResponse: renderUserDefinedResponse, userDefinedResponseEvents });
  }
  return null;
}
function loadWebChat(managedWebChat, hostURL, setInstance, instanceRef, onBeforeRender, onAfterRender, setUserDefinedResponseEvents) {
  return __awaiter(this, void 0, void 0, function() {
    var webChatConfig, message, configWithoutOnLoad, instance;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          webChatConfig = managedWebChat.webChatConfig;
          return [4, ensureWebChatScript(webChatConfig, hostURL)];
        case 1:
          _a.sent();
          if (managedWebChat.shouldDestroy) {
            logger(webChatConfig, "Destroying web chat before an instance is created.");
            destroyWebChat(managedWebChat, setInstance, instanceRef);
            return [
              2
              /*return*/
            ];
          }
          if (webChatConfig.onLoad) {
            message = "Do not use onLoad in the web chat config. Use the WebChatContainer onBeforeRender or onAfterRender prop instead.";
            logger(webChatConfig, message);
          }
          logger(webChatConfig, "Creating web chat instance.");
          configWithoutOnLoad = __assign(__assign({}, webChatConfig), { onLoad: null });
          return [4, window.loadWatsonAssistantChat(configWithoutOnLoad)];
        case 2:
          instance = _a.sent();
          addUserDefinedResponseHandler(instance, setUserDefinedResponseEvents);
          return [4, onBeforeRender === null || onBeforeRender === void 0 ? void 0 : onBeforeRender(instance)];
        case 3:
          _a.sent();
          logger(webChatConfig, "Calling render.");
          return [4, instance.render()];
        case 4:
          _a.sent();
          return [4, onAfterRender === null || onAfterRender === void 0 ? void 0 : onAfterRender(instance)];
        case 5:
          _a.sent();
          setInstance(instance);
          managedWebChat.instance = instance;
          if (instanceRef) {
            instanceRef.current = instance;
          }
          if (managedWebChat.shouldDestroy) {
            logger(webChatConfig, "Destroying web chat after an instance is created but before calling onLoad.");
            destroyWebChat(managedWebChat, setInstance, instanceRef);
          }
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function addUserDefinedResponseHandler(webChatInstance, setUserDefinedResponseEvents) {
  function userDefinedResponseHandler(event) {
    setUserDefinedResponseEvents(function(eventsArray) {
      return eventsArray.concat(event);
    });
  }
  function restartHandler() {
    setUserDefinedResponseEvents([]);
  }
  var webChatVersion = webChatInstance.getWidgetVersion();
  var eventName = compareVersions(webChatVersion, "8.2.0") >= 0 ? "userDefinedResponse" : "customResponse";
  webChatInstance.on({ type: eventName, handler: userDefinedResponseHandler });
  webChatInstance.on({ type: "restartConversation", handler: restartHandler });
}
function destroyWebChat(managedWebChat, setInstance, instanceRef) {
  if (managedWebChat) {
    if (managedWebChat.instance) {
      logger(managedWebChat.webChatConfig, "Destroying web chat instance.");
      managedWebChat.instance.destroy();
    }
    managedWebChat.shouldDestroy = true;
    managedWebChat.instance = null;
  }
  setInstance(null);
  if (instanceRef) {
    instanceRef.current = null;
  }
}
function setEnableDebug(enableDebug) {
  debug = enableDebug;
}
function logger(webChatConfig) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (debug) {
    var namespaceLabel = (webChatConfig === null || webChatConfig === void 0 ? void 0 : webChatConfig.namespace) ? ": Namespace ".concat(webChatConfig.namespace) : "";
    console.log.apply(console, __spreadArray(["[IBM watsonx Assistant WebChatContainer".concat(namespaceLabel, "]")], args, false));
  }
}
function removeTrailingSlash(value) {
  return value.replace(/\/$/, "");
}
function ensureWebChatScript(webChatConfig, hostURL) {
  return __awaiter(this, void 0, void 0, function() {
    var useURL, scriptURL, loadedWebChatURL, message;
    return __generator(this, function(_a) {
      useURL = DEFAULT_BASE_URL;
      if (hostURL) {
        useURL = removeTrailingSlash(hostURL);
      } else if (webChatConfig.cloudPrivateHostURL) {
        useURL = "".concat(removeTrailingSlash(webChatConfig.cloudPrivateHostURL), "/static/webchat");
      }
      scriptURL = "".concat(useURL, "/versions/").concat(webChatConfig.clientVersion || "latest", "/WatsonAssistantChatEntry.js");
      loadedWebChatURL = window.wacWebChatContainerScriptURL;
      if (loadedWebChatURL && loadedWebChatURL !== scriptURL) {
        message = "Web chat has already been loaded using a different URL (".concat(loadedWebChatURL, "). This component does not support loading web chat using multiple URLs including different versions of web chat. The current code attempted to load from ").concat(scriptURL, ".");
        logger(null, message);
      }
      if (!window.wacWebChatContainerScriptPromise) {
        logger(null, "Loading the web chat javascript from ".concat(scriptURL, "."));
        window.wacWebChatContainerScriptPromise = new Promise(function(resolve, reject) {
          var scriptElement = document.createElement("script");
          scriptElement.onload = function() {
            return resolve();
          };
          scriptElement.onerror = function() {
            return reject();
          };
          scriptElement.src = scriptURL;
          document.head.appendChild(scriptElement);
          window.wacWebChatContainerScriptURL = scriptURL;
        });
      }
      return [2, window.wacWebChatContainerScriptPromise];
    });
  });
}
var CUSTOM_ELEMENT_STYLES = "\n#WACContainer.WACContainer .HideWebChat { display: none }\n.CustomElementHideWebChat { width: 0; height: 0 }\n";
function WebChatCustomElement(props) {
  var _this = this;
  var className = props.className, id = props.id, onViewChange = props.onViewChange, config = props.config, onBeforeRender = props.onBeforeRender, containerProps = __rest(props, ["className", "id", "onViewChange", "config", "onBeforeRender"]);
  var _a = (0, import_react.useState)(), customElement = _a[0], setCustomElement = _a[1];
  var useConfig = (0, import_react.useMemo)(function() {
    return __assign(__assign({}, config), { element: customElement });
  }, [config, customElement]);
  var onBeforeRenderOverride = (0, import_react.useCallback)(function(instance) {
    return __awaiter(_this, void 0, void 0, function() {
      function defaultViewChangeHandler(event, instance2) {
        if (event.newViewState.mainWindow) {
          customElement.classList.remove("CustomElementHideWebChat");
          instance2.elements.getMainWindow().removeClassName("HideWebChat");
        } else {
          customElement.classList.add("CustomElementHideWebChat");
          instance2.elements.getMainWindow().addClassName("HideWebChat");
        }
      }
      return __generator(this, function(_a2) {
        instance.on({ type: "view:change", handler: onViewChange || defaultViewChangeHandler });
        return [2, onBeforeRender === null || onBeforeRender === void 0 ? void 0 : onBeforeRender(instance)];
      });
    });
  }, [onBeforeRender, onViewChange, customElement]);
  return import_react.default.createElement(
    import_react.default.Fragment,
    null,
    import_react.default.createElement("div", { className, id, ref: setCustomElement }),
    !onViewChange && import_react.default.createElement("style", null, CUSTOM_ELEMENT_STYLES),
    customElement && import_react.default.createElement(WebChatContainer, __assign({ config: useConfig, onBeforeRender: onBeforeRenderOverride }, containerProps))
  );
}
export {
  WebChatContainer,
  WebChatCustomElement,
  setEnableDebug
};
//# sourceMappingURL=@ibm-watson_assistant-web-chat-react.js.map
